// Copyright Maarten L. Hekkelman, Radboud University 2008-2011.
//   Distributed under the Boost Software License, Version 1.0.
//       (See accompanying file LICENSE_1_0.txt or copy at    
//             http://www.boost.org/LICENSE_1_0.txt)      
//
// A DSSP reimplementation

#include "mas.h"

#if defined(_MSC_VER)
#include <conio.h>
#include <ctype.h>
#endif

#include <fstream>

#include <boost/program_options.hpp>
#include <boost/iostreams/filtering_stream.hpp>
#include <boost/iostreams/copy.hpp>
#if defined USE_COMPRESSION
#include <boost/iostreams/filter/bzip2.hpp>
#include <boost/iostreams/filter/gzip.hpp>
#endif
#include <boost/algorithm/string.hpp>

//basic progress bar when reading trajectory file
#include <boost/progress.hpp>

#include "dssp.h"
#include "structure.h"
#include "iocif.h"

#include "dcd_r.hpp"

using namespace std;
namespace po = boost::program_options;
namespace io = boost::iostreams;
namespace ba = boost::algorithm;

int VERBOSE = 0;

/*
 * 
 * Modification from F. Hedin <florent.hedin@unibas.ch>, October 2015, University of Basel, Switzerland
 * 
 * added 3 functions at the end of the file : 
 *  + noTraj() just contain code from main() that was written by authors cited at top of this file : standard use of dssp on just one pdb file
 *  + the withTraj() is a modified version which reads a dcd Molecular Dynamics file, as generated by CHARMM NAMD or X-PLOR (only tested with CHARMM)
 *      it will perform the secondary structure detection on each frame of the trajectory. Command line interface was modified by addition of a --dcd argument for providing path to trajectory
 * + get_indices_of_atoms_to_update() is required by withTraj(), it maps atom indices as stored in the MChain and MResidues classes to the ones from dcd files
 * 
 */
void noTraj(MProtein& a, string& input, io::filtering_stream<io::input>& in, po::variables_map& vm);
void withTraj(MProtein& a, string& input, io::filtering_stream<io::input>& in, po::variables_map& vm,
              string dcdname);
vector<uint32> get_indices_of_atoms_to_update(MProtein& a);

int main(int argc, char* argv[])
{
	try
	{
		po::options_description desc("mkdssp " VERSION " options");
		desc.add_options()
			("help,h",							 "Display help message")
			("input,i",		po::value<string>(), "Input file")
			("output,o",	po::value<string>(), "Output file, use 'stdout' to output to screen")
			("verbose,v",						 "Verbose output")
			("version",							 "Print version")
			("debug,d",		po::value<int>(),	 "Debug level (for even more verbose output)")
      ("dcd", po::value<string>(), "For providing a CHARMM/NAMD/X-PLOR trajectory (extension should be .dcd) ; sec. structure analysis will be performed for all the frames")
			;
	
		po::positional_options_description p;
		p.add("input", 1);
		p.add("output", 2);
	
		po::variables_map vm;
		po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
		po::notify(vm);

		if (vm.count("version"))
		{
			cout << "mkdssp version " VERSION << endl;
			exit(0);
		}

		if (vm.count("help") or not vm.count("input"))
		{
			cerr << desc << endl
				 << endl
				 << "Examples: " << endl
				 << endl
				 << "To calculate the secondary structure for the file 1crn.pdb and" << endl
				 << "write the result to a file called 1crn.dssp, you type:" << endl
				 << endl
				 << "  " << argv[0] << " -i 1crn.pdb -o 1crn.dssp" << endl
				 << endl;
#if defined(_MSC_VER)
			cerr << endl
				 << "MKDSSP is a command line application, use the 'Command prompt' application" << endl
				 << "to start " << argv[0] << " You can find the 'Command prompt' in the Start menu:" << endl
				 << endl
				 << "Start => Accessories => Command prompt" << endl
				 << endl
				 << endl
				 << "Press any key to continue..." << endl;
			char ch = _getch();
#endif
			exit(1);
		}
		
		string dcdname="";
    bool withDCD = false;
		if(vm.count("dcd"))
    {
      dcdname = vm["dcd"].as<string>();
      cout << "Will process dcd file : " << dcdname << endl;
      ifstream dcdfile;
      dcdfile.open(dcdname.c_str(), ios_base::in | ios_base::binary);
      if (not dcdfile.is_open())
        throw runtime_error("No such dcd file : " + dcdname);
      withDCD = true;
      dcdfile.close();
    }

		VERBOSE = vm.count("verbose") != 0;
		if (vm.count("debug"))
			VERBOSE = vm["debug"].as<int>();
		
		string input = vm["input"].as<string>();

		ifstream infile(input.c_str(), ios_base::in | ios_base::binary);
		if (not infile.is_open())
			throw runtime_error("No such file");
		
		io::filtering_stream<io::input> in;
		
#if defined USE_COMPRESSION
		if (ba::ends_with(input, ".bz2"))
		{
			in.push(io::bzip2_decompressor());
			input.erase(input.length() - 4);
		}
		else if (ba::ends_with(input, ".gz"))
		{
			in.push(io::gzip_decompressor());
			input.erase(input.length() - 3);
		}
#endif
		
		in.push(infile);
	
		// OK, we've got the file, now create a protein
		MProtein a;

    if(withDCD)
      withTraj(a, input, in, vm, dcdname);
    else
      noTraj(a, input, in, vm);

	}
	catch (const exception& e)
	{
		cerr << "DSSP could not be created due to an error:" << endl
			 << e.what() << endl;
		exit(1);
	}
	
	return 0;
}

/*
 * Original code from main() just moved here
 */
void noTraj(MProtein& a, string& input, io::filtering_stream<io::input>& in, po::variables_map& vm)
{
  if (ba::ends_with(input, ".cif"))
    a.ReadmmCIF(in);
  else
    a.ReadPDB(in);
  
  // then calculate the secondary structure
  a.CalculateSecondaryStructure();
  
  // and finally report the secondary structure in the DSSP format
  // either to cout or an (optionally compressed) file.
  if (vm.count("output"))
  {
    string output = vm["output"].as<string>();
    
    ofstream outfile(output.c_str(), ios_base::out|ios_base::trunc|ios_base::binary);
    if (not outfile.is_open())
      throw runtime_error("could not create output file");
    
    io::filtering_stream<io::output> out;
    #if defined USE_COMPRESSION
    if (ba::ends_with(output, ".bz2"))
      out.push(io::bzip2_compressor());
    else if (ba::ends_with(output, ".gz"))
      out.push(io::gzip_compressor());
    #endif
    out.push(outfile);
    
    WriteDSSP(a, out);
  }
  else
    WriteDSSP(a, cout);
}

/*
 * Code for performing secondary structure analysis to a MD trajectory generated by CHARMM, NAMD or X-PLOR
 */
void withTraj(MProtein& a, string& input, io::filtering_stream<io::input>& in, po::variables_map& vm,
              string dcdname)
{
  if (ba::ends_with(input, ".cif"))
    a.ReadmmCIF(in);
  else
    a.ReadPDB(in);
  
  bool FileOutput = vm.count("output");
  string output;
  ofstream outfile;
  io::filtering_stream<io::output> out;
  if(FileOutput)
  {
    output = vm["output"].as<string>();
    
    outfile.open(output.c_str(), ios_base::out|ios_base::trunc|ios_base::binary);
    
    if (not outfile.is_open())
      throw runtime_error("could not create output file");

    #if defined USE_COMPRESSION
    if (ba::ends_with(output, ".bz2"))
      out.push(io::bzip2_compressor());
    else if (ba::ends_with(output, ".gz"))
      out.push(io::gzip_compressor());
    #endif
    out.push(outfile);
  }

  /* DCD stuff goes here */
  
  // get atom indices
  vector<uint32> atoms_indices = get_indices_of_atoms_to_update(a);
  
  // instance of a new object DCD_R attached to a dcd file 
  DCD_R dcdf(dcdname.c_str());
  // read the header and print it
  dcdf.read_header();
  //dcdf.printHeader();
  
  boost::progress_display show_progress(dcdf.getNFILE());

  // important : coordinates from trajectory files are always in simple precision so need to cast to double later
  const float *x,*y,*z;
  vector<MPoint> crds;
  
  const vector<MChain*>& chains = a.GetChains();

  // in this loop the coordinates are read frame by frame
  for(int i=0;i<dcdf.getNFILE();i++)
  {
    dcdf.read_oneFrame();

    x=dcdf.getX();
    y=dcdf.getY();
    z=dcdf.getZ();
    
    // store coordinates to a format compatible with dssp internals
    // we use indices taken from MResidue list built by the a.ReadPDB
    for(uint32 idx : atoms_indices)
      crds.push_back( MPoint( (double) x[idx] , (double) y[idx] , (double) z[idx] ) );
    
    uint32 indx=0;
    // update coordinates for all chains and all their residues
    for(MChain* chain : chains)
    {
      vector<MResidue*>& residues = chain->GetResidues();
      for(MResidue* res : residues)
      {
        // get references to backbone atoms
        MAtom& N  = res->GetN();
        MAtom& CA = res->GetCAlpha();
        MAtom& C = res->GetC();
        MAtom& O = res->GetO();
        
        //... and to side chain atoms also
        vector<MAtom>& side = res->GetSideChain();
        
        // update coordinates of backbone
        N.mLoc  = crds[indx++];
        CA.mLoc = crds[indx++];
        C.mLoc  = crds[indx++];
        O.mLoc  = crds[indx++];
        
        //... and of side chain atoms also
        for(MAtom& at : side)
          at.mLoc = crds[indx++];
        
      }// residues loop
      
    }// chains loop

    crds.clear();
    
    // then calculate the secondary structure
    a.CalculateSecondaryStructure();
    
    // and finally report the secondary structure in the DSSP format
    // either to cout or an (optionally compressed) file.
    if (FileOutput)
      WriteDSSP(a, out);
    else
      WriteDSSP(a, cout);
    
    //increment terminal progress bar
    ++show_progress;
    
  } // loop over all dcd frames
  
}

/*
 * After parsing the pdb, when using the trajectiry mode, this function is used for mapping the atom indices stored internally to the one from trajectory file
 */
vector<uint32> get_indices_of_atoms_to_update(MProtein& a)
{

  // get chains
  const vector<MChain*>& chains = a.GetChains();
  
  // vector for storing atom indices
  vector<uint32> indices;
  
  // iterate over all the chains
  for(const MChain* chain : chains)
  {
    // for storing references to all residues of all chains
    const vector<MResidue*>& residues = chain->GetResidues();

    // iterate over residues
    for(const MResidue* res : residues)
    {

      // get indices of N CA C O H and other side chain atoms as we will update their coordinates
      indices.push_back(res->GetN().mSerial);
      indices.push_back(res->GetCAlpha().mSerial);
      indices.push_back(res->GetC().mSerial);
      indices.push_back(res->GetO().mSerial);
      const vector<MAtom>& other_atoms = res->GetSideChain();
      
      for(const MAtom& at : other_atoms)
        indices.push_back(at.mSerial);
    }
    
  }
  
  // to c style index i.e. starting from 0
  for(uint32& ind : indices)
    ind--;
  
  return indices;
}


